/*
Signadot API

API for Signadot Sandboxes

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// SandboxesApiService SandboxesApi service
type SandboxesApiService service

type ApiCreateNewSandboxRequest struct {
	ctx context.Context
	ApiService *SandboxesApiService
	orgName string
	data *CreateSandboxRequest
}

// Request to create sandbox
func (r ApiCreateNewSandboxRequest) Data(data CreateSandboxRequest) ApiCreateNewSandboxRequest {
	r.data = &data
	return r
}

func (r ApiCreateNewSandboxRequest) Execute() (*CreateSandboxResponse, *http.Response, error) {
	return r.ApiService.CreateNewSandboxExecute(r)
}

/*
CreateNewSandbox Create a new sandbox

Creates a new sandbox with the provided parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgName Signadot Org Name
 @return ApiCreateNewSandboxRequest
*/
func (a *SandboxesApiService) CreateNewSandbox(ctx context.Context, orgName string) ApiCreateNewSandboxRequest {
	return ApiCreateNewSandboxRequest{
		ApiService: a,
		ctx: ctx,
		orgName: orgName,
	}
}

// Execute executes the request
//  @return CreateSandboxResponse
func (a *SandboxesApiService) CreateNewSandboxExecute(r ApiCreateNewSandboxRequest) (*CreateSandboxResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSandboxResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxesApiService.CreateNewSandbox")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{orgName}/sandboxes"
	localVarPath = strings.Replace(localVarPath, "{"+"orgName"+"}", url.PathEscape(parameterToString(r.orgName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["signadot-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSandboxByIdRequest struct {
	ctx context.Context
	ApiService *SandboxesApiService
	orgName string
	sandboxID string
}

func (r ApiDeleteSandboxByIdRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteSandboxByIdExecute(r)
}

/*
DeleteSandboxById Delete a Sandbox by ID

Delete the sandbox when its ID is specified

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgName Signadot Org Name
 @param sandboxID Sandbox ID
 @return ApiDeleteSandboxByIdRequest
*/
func (a *SandboxesApiService) DeleteSandboxById(ctx context.Context, orgName string, sandboxID string) ApiDeleteSandboxByIdRequest {
	return ApiDeleteSandboxByIdRequest{
		ApiService: a,
		ctx: ctx,
		orgName: orgName,
		sandboxID: sandboxID,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SandboxesApiService) DeleteSandboxByIdExecute(r ApiDeleteSandboxByIdRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxesApiService.DeleteSandboxById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{orgName}/sandboxes/{sandboxID}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgName"+"}", url.PathEscape(parameterToString(r.orgName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxID"+"}", url.PathEscape(parameterToString(r.sandboxID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["signadot-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSandboxByNameRequest struct {
	ctx context.Context
	ApiService *SandboxesApiService
	orgName string
	name string
}

func (r ApiDeleteSandboxByNameRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteSandboxByNameExecute(r)
}

/*
DeleteSandboxByName Delete Sandbox By Name

Delete Sandbox with given name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgName Signadot Org Name
 @param name Sandbox Name to search for
 @return ApiDeleteSandboxByNameRequest
*/
func (a *SandboxesApiService) DeleteSandboxByName(ctx context.Context, orgName string, name string) ApiDeleteSandboxByNameRequest {
	return ApiDeleteSandboxByNameRequest{
		ApiService: a,
		ctx: ctx,
		orgName: orgName,
		name: name,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SandboxesApiService) DeleteSandboxByNameExecute(r ApiDeleteSandboxByNameRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxesApiService.DeleteSandboxByName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{orgName}/sandboxes/by-name/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgName"+"}", url.PathEscape(parameterToString(r.orgName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["signadot-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSandboxByIdRequest struct {
	ctx context.Context
	ApiService *SandboxesApiService
	orgName string
	sandboxID string
}

func (r ApiGetSandboxByIdRequest) Execute() (*GetSandboxByIdResponse, *http.Response, error) {
	return r.ApiService.GetSandboxByIdExecute(r)
}

/*
GetSandboxById Get a Sandbox by ID

Fetch the details about a sandbox when its ID is specified

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgName Signadot Org Name
 @param sandboxID Sandbox ID
 @return ApiGetSandboxByIdRequest
*/
func (a *SandboxesApiService) GetSandboxById(ctx context.Context, orgName string, sandboxID string) ApiGetSandboxByIdRequest {
	return ApiGetSandboxByIdRequest{
		ApiService: a,
		ctx: ctx,
		orgName: orgName,
		sandboxID: sandboxID,
	}
}

// Execute executes the request
//  @return GetSandboxByIdResponse
func (a *SandboxesApiService) GetSandboxByIdExecute(r ApiGetSandboxByIdRequest) (*GetSandboxByIdResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSandboxByIdResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxesApiService.GetSandboxById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{orgName}/sandboxes/{sandboxID}"
	localVarPath = strings.Replace(localVarPath, "{"+"orgName"+"}", url.PathEscape(parameterToString(r.orgName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxID"+"}", url.PathEscape(parameterToString(r.sandboxID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["signadot-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSandboxReadyRequest struct {
	ctx context.Context
	ApiService *SandboxesApiService
	orgName string
	sandboxID string
}

func (r ApiGetSandboxReadyRequest) Execute() (*SandboxReadyResponse, *http.Response, error) {
	return r.ApiService.GetSandboxReadyExecute(r)
}

/*
GetSandboxReady Check sandbox readiness

Checks readiness of a sandbox with rate limiting enforced by polling.  Deprecated, please use getSandboxStatusById instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgName Signadot Org Name
 @param sandboxID Sandbox ID
 @return ApiGetSandboxReadyRequest

Deprecated
*/
func (a *SandboxesApiService) GetSandboxReady(ctx context.Context, orgName string, sandboxID string) ApiGetSandboxReadyRequest {
	return ApiGetSandboxReadyRequest{
		ApiService: a,
		ctx: ctx,
		orgName: orgName,
		sandboxID: sandboxID,
	}
}

// Execute executes the request
//  @return SandboxReadyResponse
// Deprecated
func (a *SandboxesApiService) GetSandboxReadyExecute(r ApiGetSandboxReadyRequest) (*SandboxReadyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SandboxReadyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxesApiService.GetSandboxReady")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{orgName}/sandboxes/{sandboxID}/ready"
	localVarPath = strings.Replace(localVarPath, "{"+"orgName"+"}", url.PathEscape(parameterToString(r.orgName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxID"+"}", url.PathEscape(parameterToString(r.sandboxID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["signadot-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSandboxStatusByIdRequest struct {
	ctx context.Context
	ApiService *SandboxesApiService
	orgName string
	sandboxID string
}

func (r ApiGetSandboxStatusByIdRequest) Execute() (*SandboxStatusResponse, *http.Response, error) {
	return r.ApiService.GetSandboxStatusByIdExecute(r)
}

/*
GetSandboxStatusById Get Sandbox Status by Sandbox ID with rate limiting.

Gets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgName Signadot Org Name
 @param sandboxID Sandbox ID
 @return ApiGetSandboxStatusByIdRequest
*/
func (a *SandboxesApiService) GetSandboxStatusById(ctx context.Context, orgName string, sandboxID string) ApiGetSandboxStatusByIdRequest {
	return ApiGetSandboxStatusByIdRequest{
		ApiService: a,
		ctx: ctx,
		orgName: orgName,
		sandboxID: sandboxID,
	}
}

// Execute executes the request
//  @return SandboxStatusResponse
func (a *SandboxesApiService) GetSandboxStatusByIdExecute(r ApiGetSandboxStatusByIdRequest) (*SandboxStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SandboxStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxesApiService.GetSandboxStatusById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{orgName}/sandboxes/{sandboxID}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"orgName"+"}", url.PathEscape(parameterToString(r.orgName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sandboxID"+"}", url.PathEscape(parameterToString(r.sandboxID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["signadot-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApierrsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v ApierrsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSandboxesRequest struct {
	ctx context.Context
	ApiService *SandboxesApiService
	orgName string
}

func (r ApiGetSandboxesRequest) Execute() (*GetSandboxesResponse, *http.Response, error) {
	return r.ApiService.GetSandboxesExecute(r)
}

/*
GetSandboxes List Sandboxes

List all sandboxes under the specified Signadot org.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgName Signadot Org Name
 @return ApiGetSandboxesRequest
*/
func (a *SandboxesApiService) GetSandboxes(ctx context.Context, orgName string) ApiGetSandboxesRequest {
	return ApiGetSandboxesRequest{
		ApiService: a,
		ctx: ctx,
		orgName: orgName,
	}
}

// Execute executes the request
//  @return GetSandboxesResponse
func (a *SandboxesApiService) GetSandboxesExecute(r ApiGetSandboxesRequest) (*GetSandboxesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSandboxesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxesApiService.GetSandboxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orgs/{orgName}/sandboxes"
	localVarPath = strings.Replace(localVarPath, "{"+"orgName"+"}", url.PathEscape(parameterToString(r.orgName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["signadot-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpsertPrWorkspaceRequest struct {
	ctx context.Context
	ApiService *SandboxesApiService
	githubOrg string
	githubRepo string
	prNumber int32
	data *UpsertPRWorkspacesRequest
}

// Request to upsert workspace
func (r ApiUpsertPrWorkspaceRequest) Data(data UpsertPRWorkspacesRequest) ApiUpsertPrWorkspaceRequest {
	r.data = &data
	return r
}

func (r ApiUpsertPrWorkspaceRequest) Execute() (*UpsertWorkspaceResponse, *http.Response, error) {
	return r.ApiService.UpsertPrWorkspaceExecute(r)
}

/*
UpsertPrWorkspace Create or Update workspace from Pull Request

Create a workspace that is associated with a specified pull request.
If no workspaces already exist for the given pull request, this creates a new workspace. Otherwise, the new changes are applied to the existing workspaces.
This endpoint uses the old terminology "workspace" instead of "sandbox" for backward compatability.
### Example

Here's an example to create/update a workspace from a pull request in the [HotROD](https://github.com/signadot/hotrod) application. To simplify the use case, consider that only the [Route Service](https://github.com/signadot/hotrod/tree/main/services/route) had changes, and that the changes were published to an image file named `signadot/hotrod-route` and tag `4e75b0b822ecbbbb4c917b0fffeb337589d82456`. This could be tagged as anything e.g. `latest`, `e2e-test` etc.

As a part of workspace creation, Signadot creates forked Kubernetes workloads (such as deployments) from existing workloads using the provided images. In order to access the forked workloads(s), `endpoints` are specified and corresponding to each endpoint, a preview URL is generated. These preview URLs are returned as part of the response. In the example below, we're dealing with a deployment named `route` in the `hotrod` namespace that is running the docker image `signadot/hotrod-route`.

In the below request to create a workspace, the deployment named `route` is forked and the fork will be created with the new docker image tag as specified by `newTag`. The new deployment that is created will be running the a new docker image tag as specified by `newTag`. There will be a single preview URL associated with this workspace as specified in `endpoints` and it will point to the fork of the `route`
deployment that was created.

```json
{
  "cluster": "signadot",
  "namespace": "hotrod",
  "headCommit": "5e35abfa94626c4853eca51ecd435a779ded4123",
  "images": [
    {
      "name": "signadot/hotrod-route",
      "newTag": "4e75b0b822ecbbbb4c917b0fffeb337589d82456"
    }
  ],
  "endpoints": [
    {
      "routeType": "fork",
      "protocol": "http",
      "forkOf": {
        "kind": "Deployment",
        "name": "route",
        "namespace": "hotrod"
      }
    }
  ]
}
```

In response the API call returns us a confirmation of the workspace created / updated along with the information on preview endpoints.

```json
{
  "workspaceIDs": [
    "xtc54uh8p2rhs"
  ],
  "previewEndpoints": [
    {
      "id": "fbm4983sxb111",
      "routeType": "fork",
      "name": "route",
      "protocol": "http",
      "clusterID": "55rjfjf3rn222",
      "cluster": "signadot",
      "forkOf": {
        "kind": "Deployment",
        "namespace": "hotrod",
        "name": "route"
      },
      "previewURL": "https://route--hotrod-131.preview.signadot.com"
    }
  ]
}

```

You can parse the `previewEndpoints` section in the response to find the previewURL associated with the endpoint created as part of the workspace.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param githubOrg GitHub Org Name
 @param githubRepo GitHub Repository Name
 @param prNumber Pull Request Number
 @return ApiUpsertPrWorkspaceRequest

Deprecated
*/
func (a *SandboxesApiService) UpsertPrWorkspace(ctx context.Context, githubOrg string, githubRepo string, prNumber int32) ApiUpsertPrWorkspaceRequest {
	return ApiUpsertPrWorkspaceRequest{
		ApiService: a,
		ctx: ctx,
		githubOrg: githubOrg,
		githubRepo: githubRepo,
		prNumber: prNumber,
	}
}

// Execute executes the request
//  @return UpsertWorkspaceResponse
// Deprecated
func (a *SandboxesApiService) UpsertPrWorkspaceExecute(r ApiUpsertPrWorkspaceRequest) (*UpsertWorkspaceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpsertWorkspaceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxesApiService.UpsertPrWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{githubOrg}/{githubRepo}/pulls/{prNumber}/workspaces"
	localVarPath = strings.Replace(localVarPath, "{"+"githubOrg"+"}", url.PathEscape(parameterToString(r.githubOrg, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"githubRepo"+"}", url.PathEscape(parameterToString(r.githubRepo, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"prNumber"+"}", url.PathEscape(parameterToString(r.prNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.data
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["signadot-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
